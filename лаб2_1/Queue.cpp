#include "Queue.h"
#include <iostream>

using namespace std;

//конструктор с параметром
Queue::Queue(int count) //передаем размер создаваемой очереди
{
	size = 0; //изначально очередь пуста
	for (int i = 0; i < count; ++i)  //добавляем count элементов в очередь
	{
		int value = rand() % 31; //берем рандомное значение от 0 до 30
		pushBack(value); //вызываем метод добавления элемента в очередь и передаем ему полученное значение
	}
}

//конструктор копирования
Queue::Queue(const Queue & other)
{
	Node *tmp = other.tail; //указатель-помощник на очередь, которую будем копировать, так как нельзя менять tail
	this->size = 0; //в объекте, в который будем копировать устанавливаем размер очереди равным 0
	int *ptr = new int[other.size]; //массив для записи туда значений из очереди, которую будем копировать

	//копируем элементы в массив, так как двигаться по очереди можно только в обратном порядке
	for (int i = 0; i < other.size; ++i)
	{
		ptr[i] = tmp->value; //записываем значение
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}

	//копируем элементы в новый объект в нужном порядке
	for (int i = other.size - 1; i >= 0; --i)
		this->pushBack(ptr[i]); //добавляем элемент

	delete[] ptr;  //выделяли память динамически, значит надо её отчистить
}

//деструктор
Queue::~Queue()
{
	Node *tmp; //указаетль-помощник
	for (int i = 0; i < size; ++i) //удаляем все size элементов из очереди
	{
		tmp = tail; //запоминаем указатель на последний элемент
		tail = tail->prev; //передвигаем tail на предпоследний элемент
		delete tmp; //удаляем последний элемент
	}
	size = 0; //очередь пуста
}

//взятие размера очереди
int Queue::getSize()
{
	return size; //просто возвращаем размер очереди
}

void Queue::pushBack(int value)
{
	Node* tmp = new Node; //создаем новый элемен, и на него будет указывать указатель new_item
	tmp->value = value; //записываем в поле value значение, которое мы передали, то есть значение, которое мы ввели
	tmp->prev = tail; // новый элемент указывает на последний в очереди элемент, т.е. перед ним
	tail = tmp; // хвост указывает на новый элемент
	size++; //увеличиваем количество элементов в очереди;
}

//вывод очереди
void Queue::showQueue()
{
	Node *tmp = tail; //указатель-помощник
	int *ptr = new int[size]; //массив для записи туда значений из очереди

	//копируем элементы в массив, так как двигаться по очереди можно только в обратном порядке
	for (int i = 0; i < size; ++i)
	{
		ptr[i] = tmp->value; //записываем значение
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}

	//выводим элементы в нужном порядке
	for (int i = size - 1; i >= 0; --i)
		cout << ptr[i] << " "; //выводим элемент

	delete[] ptr; //выделяли память динамически, значит надо её отчистить
}

//перегрузка оператора присваивания, объект слева текущий (this), объект справа передан в качестве параметра
Queue & Queue::operator=(const Queue & other)
{
	Node *tmp1 = tail; //указатель на очередь слева от =
	Node *tmp2 = other.tail; //указатель на очередь справа от =

	for (int i = 0; i < size; ++i) //пробегаемся по всей очереди
	{
		tmp1->value = tmp2->value;  //присваиваем элементу очереди слева значение элемента очереди справа
		tmp1 = tmp1->prev; //передвигаем указатель на предыдущий элемент очереди слева
		tmp2 = tmp2->prev; //передвигаем указатель на предыдущий элемент очереди справа
	}
	return *this; //возвращаем объект слева от =, то есть это текущий объект
}

//перегрузка оператора отрицание
Queue Queue::operator!()
{
	Queue res(*this); //создаем копию объекта с помощью конструктора копирования
	Node *tmp = res.tail; //указатель на конец очереди локального объекта 
	for (int i = 0; i < size; ++i) //пробигаемся по всей очереди
	{
		tmp->value *= -1; //каждый элемент умножаем на -1
		tmp = tmp->prev; //передвигаем указатель
	}
	return res;
}

Queue & Queue::operator++()
{
	int val; //значние, на котрое будем увеличивать
	cout << "Введите значение для увеличения очереди: ";
	cin >> val;

	Node *tmp = tail; //указатель-помощник
	for (int i = 0; i < size; ++i)
	{
		tmp->value += val; //прибавляем введенное значение к значению из очереди
		tmp = tmp->prev; //передвигаем указатель
	}
	return *this; //возвращаем объект
}

//аналогично префиксному инкременту, только мы вычитаем введенное значение
Queue & Queue::operator--()
{
	int val;
	cout << "Введите значение для уменьшения очереди: ";
	cin >> val;

	Node *tmp = tail;
	for (int i = 0; i < size; ++i)
	{
		tmp->value -= val;
		tmp = tmp->prev;
	}
	return *this;
}

//постфикс
Queue Queue::operator++(int)
{
	Queue res(*this); //запомниаем исходное состояние объекта, а после делаем с ним, что хотим

	Node *tmp = tail; //указатель-помощник
	for (int i = 0; i < size; ++i) //к каждому значению очереди прибавляем размер очереди
	{
		tmp->value += size;
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}

	return res; //возвращаем локальный объект, который хранит в себе изначальное состояние объекта this
}

//постфикс
Queue Queue::operator--(int)
{
	Queue res(*this); //запомниаем исходное состояние объекта, а после делаем с ним, что хотим

	Node *tmp = tail; //указатель-помощник
	for (int i = 0; i < size; ++i) //из каждого значения очереди вычитаем удвоинный размер очереди
	{
		tmp->value -= 2 * size;
		tmp = tmp->prev; //передвигаем указатель на предыдущий элемент
	}

	return res; //возвращаем локальный объект, который хранит в себе изначальное состояние объекта this
}

